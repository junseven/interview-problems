# 事件循环event loop
> 调用栈(call stack)   消息队列(message queue)包括 
微任务队列(mircotask queue)宏任务队列(marcotask queue)

在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。
一个宏任务内同步事件依次压入调入栈并执行,微任务回调函数放到微任务队列在同步事件执行完之后执行,宏任务放到宏任务队列在微任务后执行. dom渲染在微任务和宏任务之间.
先执行同步事件,后执行微任务,最后宏任务
# http缓存
## 强缓存

强缓存不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

## 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
* 协商缓存生效，返回304和Not Modified
* 协商缓存失效，返回200和请求结果

>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 
频繁变动使用cache-control:no-cache
不常变动使用Cache-Control: max-age=31536000

# 细说浏览器输入URL后发生了什么
## 1. DNS域名解析
## 2. 建立TCP连接
## 3. 发送HTTP请求，服务器处理请求，返回响应结果
## 4. 关闭TCP连接
## 5. 浏览器渲染
> 按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示
1. 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
6. 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

* 构建 DOM 树
* 样式计算
* 页面布局
* 生成分层树
* 栅格化
* 显示

# http的基本结构
> 起始行 + 头部 + 空行 + 实体
## 起始行
请求报文：`GET /home HTTP/1.1  ` 也就是方法+路径+http版本
响应报文：`HTTP/1.1 200 OK`  响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。

## 头部
## 空行
## 实体

# 状态码
## 1xx 信息性状态码
接受的请求正在处理

## 2XX 成功
1. 200 ok（请求成功）
2. 204 no content （请求成功，但是没有结果返回）
3. 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）

## 3XX 重定向
1. 301 move permanently （永久性重定向）
2. 302 found （临时性重定向）
3. 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源）
4. 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）
5. 307 temporary redirect （跟302一个意思）
## 4XX 客户端错误
1. 400 bad request （请求报文存在语法错误）
2. 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））
3. 403 forbidden （请求被服务器拒绝了）
4. 404 not found （服务器上无法找到请求的资源）# ## 5XX 服务器错误
1. 500 internal server error （服务端执行请求时发生了错误）
2. 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

# https
在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS.
http默认端口号80，https默认端口号443

# 什么是同源策略
* 一个域下的js脚本未经允许的情况下，不能访问另个域的内容。通常判断跨域的依据是协议，域名，端口号是否相同，不同则跨域。同源策略是对js脚本的一种限制，并不是对浏览器的限制，想img，script脚本请求不会有跨域。

# 能不能说一说浏览器的本地存储？各自优劣如何？
浏览器的本地存储主要分为Cookie、WebStorage和IndexDB, 其中WebStorage又可以分为localStorage和sessionStorage。
** 共同点 ** : 都是保存在浏览器端、且同源的
** 不同点 **： 

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
2. 存储大小限制也不同，


*cookie数据不能超过4K，sessionStorage和localStorage可以达到5M
*sessionStorage：仅在当前浏览器窗口关闭之前有效；
*localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；
*cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭

3. 作用域不同

sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在
cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在


# Cookie、Session、Token、JWT
## 什么是 Cookie
* **HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）**：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
* **cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
* **cookie 是不可跨域的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。

# 什么是 Session
* session 是另一种记录服务器和客户端会话状态的机制
* session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

Cookie 和 Session 的区别

安全性： Session 比 Cookie 安全。存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

# 什么是 JWT
## JWT 的原理
JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户,以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。
## 使用方法
客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。
此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。


# Token 和 JWT 的区别 
相同：

都是访问资源的令牌
都可以记录用户的信息
都是使服务端无状态化
都是只有验证成功后，客户端才能访问服务端上受保护的资源

区别：

Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。

# 事件循环event loop
> 调用栈(call stack)   消息队列(message queue)包括 
微任务队列(mircotask queue)宏任务队列(marcotask queue)

在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。
一个宏任务内同步事件依次压入调入栈并执行,微任务回调函数放到微任务队列在同步事件执行完之后执行,宏任务放到宏任务队列在微任务后执行. dom渲染在微任务和宏任务之间.
先执行同步事件,后执行微任务,最后宏任务
# http缓存
## 强缓存

强缓存不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

## 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
* 协商缓存生效，返回304和Not Modified
* 协商缓存失效，返回200和请求结果

>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 
频繁变动使用cache-control:no-cache
不常变动使用Cache-Control: max-age=31536000

# 细说浏览器输入URL后发生了什么
## 1. DNS域名解析
## 2. 建立TCP连接
## 3. 发送HTTP请求，服务器处理请求，返回响应结果
## 4. 关闭TCP连接
## 5. 浏览器渲染
> 按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示
1. 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
6. 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

* 构建 DOM 树
* 样式计算
* 页面布局
* 生成分层树
* 栅格化
* 显示

# http的基本结构
> 起始行 + 头部 + 空行 + 实体
## 起始行
请求报文：`GET /home HTTP/1.1  ` 也就是方法+路径+http版本
响应报文：`HTTP/1.1 200 OK`  响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。

## 头部
## 空行
## 实体

# 状态码
## 1xx 信息性状态码
接受的请求正在处理

## 2XX 成功
1. 200 ok（请求成功）
2. 204 no content （请求成功，但是没有结果返回）
3. 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）

## 3XX 重定向
1. 301 move permanently （永久性重定向）
2. 302 found （临时性重定向）
3. 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源）
4. 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）
5. 307 temporary redirect （跟302一个意思）
## 4XX 客户端错误
1. 400 bad request （请求报文存在语法错误）
2. 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））
3. 403 forbidden （请求被服务器拒绝了）
4. 404 not found （服务器上无法找到请求的资源）# ## 5XX 服务器错误
1. 500 internal server error （服务端执行请求时发生了错误）
2. 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

# https
在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS.
http默认端口号80，https默认端口号443

# 什么是同源策略
* 一个域下的js脚本未经允许的情况下，不能访问另个域的内容。通常判断跨域的依据是协议，域名，端口号是否相同，不同则跨域。同源策略是对js脚本的一种限制，并不是对浏览器的限制，想img，script脚本请求不会有跨域。

# 能不能说一说浏览器的本地存储？各自优劣如何？
浏览器的本地存储主要分为Cookie、WebStorage和IndexDB, 其中WebStorage又可以分为localStorage和sessionStorage。
** 共同点 ** : 都是保存在浏览器端、且同源的
** 不同点 **： 

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
2. 存储大小限制也不同，


*cookie数据不能超过4K，sessionStorage和localStorage可以达到5M
*sessionStorage：仅在当前浏览器窗口关闭之前有效；
*localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；
*cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭

3. 作用域不同

sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在
cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
